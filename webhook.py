import os
import glob
import traceback
import base64
from flask import Flask, request, jsonify
import requests
from run_tutorial import generate_tutorial

app = Flask(__name__)

GITHUB_TOKEN   = os.getenv("GITHUB_TOKEN")
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET")   # set this in Heroku config
OUTPUT_DIR     = os.getenv("OUTPUT_DIR", "output")
TUTORIAL_LANG  = os.getenv("TUTORIAL_LANG", "english")

def verify_signature(req):
    import hmac, hashlib
    header = req.headers.get("X-Hub-Signature-256", "")
    if not header:
        return False
    sha_name, sig = header.split("=", 1)
    if sha_name != "sha256":
        return False
    mac = hmac.new(WEBHOOK_SECRET.encode(), msg=req.data, digestmod=hashlib.sha256)
    return hmac.compare_digest(mac.hexdigest(), sig)

@app.route("/payload", methods=["POST"])
def payload():
    try:
        # 1) verify signature
        if WEBHOOK_SECRET and not verify_signature(request):
            return "Invalid signature", 401

        event = request.headers.get("X-GitHub-Event", "")
        if event != "pull_request":
            return jsonify({"msg": f"Ignoring event {event}"}), 200

        pr = request.json["pull_request"]
        action = pr.get("action", "")
        if action not in ("opened", "synchronize", "reopened"):
            return jsonify({"msg": f"Ignoring action {action}"}), 200

        # 2) build clone URL with PAT
        repo = pr["head"]["repo"]
        raw_clone = repo["clone_url"]  # e.g. https://github.com/you/repo.git
        clone_url = raw_clone.replace(
            "https://",
            f"https://{GITHUB_TOKEN}@"
        )
        branch = pr["head"]["ref"]

        # 3) generate tutorial
        tutorial_dir = generate_tutorial(
            repo_url=clone_url,
            token=None,
            output=OUTPUT_DIR,
            language=TUTORIAL_LANG
        )

        # 4) read the generated markdown file
        md_files = glob.glob(os.path.join(tutorial_dir, "*.md"))
        if not md_files:
            raise RuntimeError("No tutorial markdown found")
        tutorial_md = open(md_files[0], encoding="utf-8").read()

        # 5) fetch existing README.md from PR branch
        owner = repo["owner"]["login"]
        slug  = repo["name"]
        api_base = "https://api.github.com"
        contents_url = (
            f"{api_base}/repos/{owner}/{slug}/contents/README.md?ref={branch}"
        )
        resp = requests.get(
            contents_url,
            headers={"Authorization": f"token {GITHUB_TOKEN}"}
        )
        if resp.status_code == 404:
            existing = ""
            sha = None
        else:
            data = resp.json()
            existing = base64.b64decode(data["content"]).decode("utf-8")
            sha = data["sha"]

        # 6) append and push back
        new_content = existing + "\n\n" + tutorial_md
        update_payload = {
            "message": "ðŸ¤– Add autogenerated tutorial",
            "content": base64.b64encode(new_content.encode("utf-8")).decode("utf-8"),
            "branch": branch
        }
        if sha:
            update_payload["sha"] = sha

        update_url = f"{api_base}/repos/{owner}/{slug}/contents/README.md"
        update_resp = requests.put(
            update_url,
            json=update_payload,
            headers={"Authorization": f"token {GITHUB_TOKEN}"}
        )
        update_resp.raise_for_status()

        return jsonify({"msg": "Tutorial appended"}), 200

    except Exception:
        traceback.print_exc()
        return jsonify({"error": traceback.format_exc()}), 500

if __name__ == "__main__":
    app.run(host="0.0.0.0",
            port=int(os.getenv("PORT", 5000)),
            debug=True)
